\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{textcomp}
\usepackage{relsize}
\usepackage{babel}
\usepackage{amsmath}

\title{INF1000}
\author{Sjur Hernes}

\begin{document}

\maketitle

\section{Tall}

\begin{tabular}{|c|c|}
  \hline
  Type & Lovlige Verdier\\
  \hline
  \hline
  byte & -128 til 127\\
  \hline
  short & -32 768 til 32 767\\
  \hline
  int & -2 147 483 648 til 2 147 483 647\\
  \hline
  long & -9 223 372 036 854 775 808L til 9 223 372 036 854 775 807L\\
  \hline
  float & \textpm3.402 823 47 E+38F(6-7 signifikante desimaler)\\
  \hline
  double & \textpm1.797 693 134 862 315 70 E+308(15 signifikante desimaler)\\
  \hline
\end{tabular}

\subsection{Integere}

Integere er heltall, og lite annet.\\
\newline
Hvis vi vil konvertere en streng til en int sier vi:\\
int x = Integer.parseInt("123");\\
\newline
Hvis vi vil konvertere et annet tall til int skriver vi:\\
int x = (int) 3.14\\
\newline 
\begin{tabular}{|c|c|c|}
  \hline
  Operasjon & Beskrivelse & Eksempel\\
  \hline
  \hline
  +, -, *, /  & De fire regneartene & 1 + 1\\
  \hline
  ++ & legge til 1 & i++; , samme som i = i+1\\
  \hline
  -- & trekke fra 1 & i--; , samme som i = i-1\\
  \hline
  \% & modulo(rest) & 5 \% 2 = 1\\
  \hline
  Math.sqrt(\dots) & kvadratrot & x = Math.sqrt(4);\\
  \hline
  Math.pow(\dots) & Potens ($x^y$) & x = Math.pow(y,z);\\
  \hline
\end{tabular}
\newline
\newline
enkle presedensregler:

\begin{enumerate}
\item metodekall
\item ++ og --
\item * og /
\item + og -
\item -(som negativt fortegn)
\end{enumerate}

husk at:\\
int x, y=1;\\
x = y++ + y + ++y;\\
nå er x = 6, fordi stykket blir 1 + 2 + 3. først er y = 1, og så øker den slik at neste gang y brukes er den 2. 
når vi skriver ++y så vil y være 3 før vi legger det til.

\subsection{desimaltall}

Jeg velger å bare leke med floats, men reglene er ca det samme som for int.\\
\newline
konvertering fra heltall til desimaltall:\\
float x = (3 + 0.0) / 2;\\
altså vi bare legger til 0.0 som det som skjer først, slik at ett av tallene er et desimaltall, 
ellers vil vi få heltallsdivisjon. Enkelt og greit, utenom det gjelder de samme opperatorene og
de samme presidensreglene.

\section{Sannhetsverdier - boolean}

\begin{tabular}{|c|c|c|}
  \hline
  Operator & Beskrivelse & Eksempel\\
  \hline
  \hline
  \&\& & Og(true hvis begge ledd er sanne) & b= (x<y) \&\& (y<z);\\
  \hline
  || & Eller(sann hvis minst ett ledd er sant) & b= (x<y) || (y<z);\\
  \hline
  ! & Ikke (snur sannhetsverdien) & b = (!true == false);\\
  \hline
  < og > & mindre enn, større enn & b = x < y;\\
  \hline
  <= og >= & mendre eller lik, større eller lik & b = y <= z;\\
  \hline
  == & Er lik & b= (x==y);\\
  \hline
  != & Er ikke lik & b= (x!=y);\\
  \hline
\end{tabular}
\newline
\newline
presidensregler
\begin{enumerate}
\item Metodekall
\item !
\item <, <=, >=, >
\item ==, !=
\item \&\&
\item ||
\end{enumerate}

\section{Tekst - strenger og char}

vi har strengen s = "kake"
\newline
\begin{tabular}{|c|c|c|}
  \hline
  Navn & Forklaring & Eksempel\\
  \hline
  \hline
  charAt(...) & tegnet i gitt posisjon(fra 0) & s.charAt(2)=='k'\\
  \hline
  length() & gir lengden på teksten & s.length()==4\\
  \hline
  substring(...) & delteksten fra- og tilposisjon & s.substring(1,3)=="ak"\\
  \hline
  & gir indeksen og ut & s.substring(1)=="ake"\\
  \hline
  equals(...) & tester likhet mellom strenger & s.equals("kake")\\
  \hline
  indexOf(...) & posisjonen til tegnet/tekst & s.indexOf('a')==1\\
  \hline
  startsWith(...) & starter teksten med ... & s.startsWith("ka")\\
  \hline
  endsWith(...) & ender teksten med ... & s.endsWith("ke")\\
  \hline
  compaireTo(...) & sammenligning av tekster & s.compaireTo("bake")<0\\
  \hline
\end{tabular}

\subsection{char}

en char-verdi er rett og slett en bokstav, den kan sammenlignes ('a' < 'b') og vil da sammenlignes ut
i fra ascii-verdier (alle store bokstaver er mindre enn de små bokstavene).

\subsection{String}

En string er en rekke med char-verdier, altså ord. Man kan legge ord sammen med pluss-opperatoren 
("heisann" + " " + navn), man kan konvertere tall til strenger på denne måten\\
String s = "" + 42;\\
og verdien til s vil være "42".

Strenger kan også deles opp i arrayer ved hjelp av en split-funksjon. eks:\\
string[ ] t = s.split(" ");

\section{Arrayer}

Arrayer er en indeksert(fra 0) gruppe av objekter. Man må definere størelsen når man lager objektet.\\
String[ ] a = new string[3];\\
man kan nå finne lengden på arrayet og bruke det som en int\\
a.length;

\section{løkker}

\begin{tabular}{|c|c|c|}
  \hline
  navn & beskrivelse & eksempel\\
  \hline
  \hline
  for & bestemt antall ganger & for(int i=0;i<3;i++)\{\}\\
  \hline
  & alle objekter i array & for(String s : a)\{\}\\
  \hline
  & alle objekter i hash & for(String s : hm.values())\\
  \hline
  while & i mens test er sann & while(1>0)\{\}\\
  \hline
  do-while & utfører løkka før testen & do \{\} while(true);\\ 
\end{tabular}

\section{hasjkart}

Hashmaps er en enkel måte å ordne mange objekter med et objekt som
indeks.\\
import java.util.*\\
HashMap<string,Person> personregister = new HashMap<String,Person>();\\
\newline
\begin{tabular}{|c|c|}
  \hline
  Metode & beskrivelse\\
  \hline
  \hline
  put(nøkkel, peker) & legge til objekt i HM\\
  \hline
  get(nøkkel) & hente peker til objekt\\
  \hline
  remove(nøkkel) & fjerne nøkkel fra HM\\
  \hline
  containsKey(nøkkel) & bool om nøkkelen er der\\
  \hline
  containsValue(objekt) & bool om objektet er der\\
  \hline
  values() & lager en mengde av alle verdiene i HM,\\
  & brukes til itterering\\
  \hline
  keySet() & brukes til å lage en mengde av alle nøklene\\
  & brukes til iterering\\
  \hline
  isEmpty() & returnerer true hvis tabellen er tom.\\
  \hline
  size() & Metoden returnerer antall nøkler i tabellen\\
  \hline
\end{tabular}

\end{document}
