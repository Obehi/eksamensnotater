% Created 2010-06-07 Mon 19:54
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{t1enc}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\documentclass[a4paper,norsk,10pt]{article}
\usepackage{fullpage} %Utnytter større del av arket.
\usepackage[sc,osf]{mathpazo} %Pen font.
\usepackage[norsk]{babel} %Norsk språkpakke.
\usepackage{hyperref} %For lenker i latex-dokument.
\hypersetup{colorlinks=true,linkcolor=black} %Farge på lenker.
\usepackage{amsmath} %Større matematikkpakke.
\usepackage[usenames,dvipsnames]{color} %Flere farger.
\usepackage{parskip} %Norsk type linjeskift.
\providecommand{\alert}[1]{\textbf{#1}}

\title{MAT1030 - Eksamensnotater}
\author{Sjur Hernes \& Eivind Lindbråten}
\date{07 June 2010}

\begin{document}

\maketitle

\setcounter{tocdepth}{3}
\tableofcontents
\vspace*{1cm}
\section{Tall}
\label{sec-1}



\begin{center}
\begin{tabular}{ll}
\hline
 \textbf{Type}  &  \textbf{Lovlige verdier}                 \\
\hline
 byte           &  \textpm{}127                             \\
\hline
 short          &  \textpm{}32 767                          \\
\hline
 int            &  \textpm{}2 147 483 647                   \\
\hline
 long           &  \textpm{}9 223 372 036 854 775 807L      \\
\hline
 float          &  \textpm{}3.402 823 47 E+38F              \\
\hline
 double         &  \textpm{}1.797 693 134 862 315 70 E+308  \\
\hline
\end{tabular}
\end{center}



  negative tall er har alltid en større range 
\subsection{Integere}
\label{sec-1_1}


   Integere er heltall, og lite annet.\\
   \newline
   Hvis vi vil konvertere en streng til en int sier vi:\\
   int x = Integer.parseInt(``123'');\\
   \newline
   Hvis vi vil konvertere et annet tall til int skriver vi:\\
   int x = (int) 3.14\\
   \newline 


\begin{center}
\begin{tabular}{lll}
\hline
 Operasjon            &  Beskrivelse          &  Eksempel             \\
\hline
 +, -, *, /           &  De fire regneartene  &  1+1                  \\
\hline
 ++                   &  legge til 1          &  i++                  \\
\hline
 --                   &  trekke fra 1         &  i--                  \\
\hline
 \%                   &  modulo(rest)         &  5\%2 -> 1            \\
\hline
 Math.sqrt(\ldots{})  &  Kvadratrot           &  Math.sqrt(4) -> 2    \\
\hline
 Math.pow(x, y)       &  Potens (x$^y$)       &  Math.pow(2, 3) -> 8  \\
\hline
\end{tabular}
\end{center}


  
   
\begin{itemize}
\item Metodekall

\begin{itemize}
\item ++ og --
\item * og /
\item + og -
\item -(som negativt fortegn)
\end{itemize}

\end{itemize}


   husk at:\\
   int x, y=1;\\
   x = y++ + y + ++y;\\
   nå er x = 6, fordi stykket blir 1 + 2 + 3. først er y = 1, og 
   så øker den slik at neste gang y brukes er den 2. 
   når vi skriver ++y så vil y være 3 før vi legger det til.
\subsection{desimaltall}
\label{sec-1_2}


   Jeg velger å bare leke med floats, men reglene er ca det samme som for int.\\

   konvertering fra heltall til desimaltall:\\
   float x = (3 + 0.0) / 2;\\

   altså vi bare legger til 0.0 som det som skjer først, slik at ett av tallene er
   et desimaltall, ellers vil vi få heltallsdivisjon. Enkelt og greit,
   utenom det gjelder de samme operatorene og de samme presidensreglene.
\section{Sannhetsverdier - boolean}
\label{sec-2}




\begin{itemize}
\item \&\&

\begin{itemize}
\item Og
\item true \&\& true
\item ||

\begin{itemize}
\item Eller
\item true || false
\end{itemize}

\end{itemize}

\item ikke
       b = !false
\item < og >

\begin{itemize}
\item mindre enn, større enn
\item b = x<y
\end{itemize}

\item <= og >=

\begin{itemize}
\item mindre eller lik
\item b = x<=y
\end{itemize}

\item ==

\begin{itemize}
\item er lik
\item b = x==y
\end{itemize}

\item !=

\begin{itemize}
\item er ikke lik
\item b = x!=y
\end{itemize}

\end{itemize}
\subsection{presidensregler}
\label{sec-2_1}


\begin{itemize}
\item Metodekall

\begin{itemize}
\item !
\item <, <=, >=, >
\item \texttt{=, !}
\item \&\&
\item ||
\end{itemize}

\end{itemize}
\section{Tekst - strenger og char}
\label{sec-3}


  vi har strengen s = ``kake''
  

\begin{center}
\begin{tabular}{lll}
\hline
 Navn                  &  Forklaring                      &  Eksempel                  \\
\hline
 charAt(\ldots{})      &  tegnet i gitt posisjon(fra 0)   &  s.charAt(2)=='k'          \\
\hline
 length()              &  gir lengden på teksten          &  s.length()==4             \\
\hline
 substring(\ldots{})   &  delteksten fra- og tilposisjon  &  s.substring(1,3)==''ak''  \\
                       &  gir indeksen og ut              &  s.substring(1)==''ake''   \\
\hline
 equals(\ldots{})      &  tester likhet mellom strenger   &  s.equals(``kake'')        \\
\hline
 indexOf(\ldots{})     &  posisjonen til tegnet/tekst     &  s.indexOf(`a')==1         \\
\hline
 startsWith(\ldots{})  &  starter teksten med \ldots{}    &  s.startsWith(``ka'')      \\
\hline
 endsWith(\ldots{})    &  ender teksten med \ldots{}      &  s.endsWith(``ke'')        \\
\hline
 compaireTo(\ldots{})  &  sammenligning av tekster        &  s.compaireTo(``bake'')<0  \\
\hline
\end{tabular}
\end{center}
\subsection{char}
\label{sec-3_1}


   en char-verdi er rett og slett en bokstav, den kan sammenlignes (`a' < `b') 
   og vil da sammenlignes ut
   i fra ascii-verdier (alle store bokstaver er mindre enn de små bokstavene).
\subsection{String}
\label{sec-3_2}


   En string er en rekke med char-verdier, altså ord. Man kan legge ord
   sammen med pluss-opperatoren 
   (``heisann'' + `` `` + navn), man kan konvertere tall til strenger på denne måten\\
   String s = ``'' + 42;\\
   og verdien til s vil være ``42''.

   Strenger kan også deles opp i arrayer ved hjelp av en split-funksjon. eks:\\
   string[ ] t = s.split(`` ``);
\section{Arrayer}
\label{sec-4}


  Arrayer er en indeksert(fra 0) gruppe av objekter. Man må definere
  størelsen når man lager objektet.
\begin{verbatim}
String[ ] a = new string[3];
\end{verbatim}
man kan nå finne lengden på arrayet og bruke det som en int a.length;
\section{løkker}
\label{sec-5}



\begin{center}
\begin{tabular}{lll}
 navn      &  beskrivelse               &  eksempel                     \\
 for       &  bestemt antall ganger     &  for(int i=0;i<3;i++)\{\}     \\
           &  alle objekter i array     &  for(String s : a)\{\}        \\
           &  alle objekter i hash      &  for(String s : hm.values())  \\
 while     &  i mens test er sann       &  while(b)\{\}                 \\
 do-while  &  utfører løkka før testen  &  do \{\} while(b);            \\
\end{tabular}
\end{center}
\subsection{while}
\label{sec-5_1}

   
   while-løkker er kanskje den enkleste formen for løkker, den gjør en blokk kode
   så lenge predikatet i parameteret er sant. 

   Man trenger ikke nødvendigvis å kjøre
   en kodeblokk, for eksempel hvis man har en boolsk funksjon (``kan()'') som parameteret
   kan man kjøre koden ``while(kan());'' og dermed si at man skal kjøre helt til ``kan()''
   returnerer false.
\subsection{for}
\label{sec-5_2}

   
   for-løkker er en naturlig utvidelse av while da man ofte trenger tellere eller ting
   som skjer for hver gang kodeblokken skal kjøres, for eksempel en teller når man går
   igjennom et array.

\begin{itemize}
\item for(int i=0;i<array.length;i++;)\{

\begin{itemize}
\item System.out.println(array[i])
\end{itemize}

\item \}
\end{itemize}


   Men for-løkker kan brukes på andre måter da den har en ganske enkel måte å oppføre 
   seg på ``for(initialiseringskode;predikat;postkode)'', eneste som det er strengt hva 
   man må ha i en for-løkke er predikatet. initialiseringen, kan være å sette en teller
   til noe, eller når man går igjennom noder i en graf, så kan man f.eks sette 
   for(Node n = root;n.next!=null;n=n.next)
\subsection{while .. do}
\label{sec-5_3}

   
   Mindre brukt løkketype, egentlig en while-løkke hvor koden kjøres minst en gang før
   predikatet blir testet.
  
\section{hasjkart}
\label{sec-6}


  Hashmaps er en enkel måte å ordne mange objekter med et objekt som
  indeks.\\
  import java.util.*\\
  HashMap<string,Person> personregister = new HashMap<String,Person>();\\
  

\begin{center}
\begin{tabular}{ll}
\hline
 Metode                 &  beskrivelse                                  \\
\hline
 put(nøkkel, peker)     &  legge til objekt i HM                        \\
\hline
 get(nøkkel)            &  hente peker til objekt                       \\
\hline
 remove(nøkkel)         &  fjerne nøkkel fra HM                         \\
\hline
 containsKey(nøkkel)    &  bool om nøkkelen er der                      \\
\hline
 containsValue(objekt)  &  bool om objektet er der                      \\
\hline
 values()               &  lager en mengde av alle verdiene i HM,       \\
                        &  brukes til itterering                        \\
\hline
 keySet()               &  brukes til å lage en mengde av alle nøklene  \\
                        &  brukes til iterering                         \\
\hline
 isEmpty()              &  returnerer true hvis tabellen er tom.        \\
\hline
 size()                 &  Metoden returnerer antall nøkler i tabellen  \\
\hline
\end{tabular}
\end{center}


  
  
\section{Lenkede lister}
\label{sec-7}

\end{document}
